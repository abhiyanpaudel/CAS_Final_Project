name: Particle2Mesh CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag (leave empty for CI-only run)'
        required: false
        default: ''

jobs:
  # Main build and test job
  build-and-test:
    runs-on: self-hosted
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for release notes generation
    
    - name: Set up environment and dependencies
      run: |
        echo "Setting up environment for dependencies"
        # Source your configuration script that sets up all paths
        source ./config.sh
        # Export variables needed by subsequent steps
        echo "DEVICE_ARCH=${DEVICE_ARCH}" >> $GITHUB_ENV
        echo "SOURCE_DIR=${SOURCE_DIR}" >> $GITHUB_ENV
        echo "BUILD_DIR=${BUILD_DIR}" >> $GITHUB_ENV
        echo "DEPENDENCY_DIR=${DEPENDENCY_DIR}" >> $GITHUB_ENV
        echo "PETSC_DIR=${PETSC_DIR}" >> $GITHUB_ENV
        echo "PETSC_ARCH=${PETSC_ARCH}" >> $GITHUB_ENV
      
    - name: Verify dependencies
      run: |
        echo "=== Verifying dependencies ==="
        echo "PETSc:"
        echo "  PETSC_DIR: $PETSC_DIR"
        echo "  PETSC_ARCH: $PETSC_ARCH"
        if [ ! -d "$PETSC_DIR" ] || [ ! -d "$PETSC_DIR/$PETSC_ARCH" ]; then
          echo "ERROR: PETSc not found at $PETSC_DIR/$PETSC_ARCH"
          exit 1
        fi
        
        echo "Kokkos:"
        KOKKOS_ROOT="$BUILD_DIR/${DEVICE_ARCH}/kokkos-meshField/install"
        echo "  KOKKOS_ROOT: $KOKKOS_ROOT"
        if [ ! -d "$KOKKOS_ROOT" ]; then
          echo "ERROR: Kokkos not found at $KOKKOS_ROOT"
          exit 1
        fi
        
        echo "Omega_h:"
        OMEGA_H_DIR="$BUILD_DIR/${DEVICE_ARCH}/omega_h-meshField/install"
        echo "  OMEGA_H_DIR: $OMEGA_H_DIR"
        if [ ! -d "$OMEGA_H_DIR" ]; then
          echo "ERROR: Omega_h not found at $OMEGA_H_DIR"
          exit 1
        fi
        
        echo "MeshFields:"
        MESHFIELDS_DIR="$BUILD_DIR/${DEVICE_ARCH}/meshField/install"
        echo "  MESHFIELDS_DIR: $MESHFIELDS_DIR"
        if [ ! -d "$MESHFIELDS_DIR" ]; then
          echo "ERROR: MeshFields not found at $MESHFIELDS_DIR"
          exit 1
        fi
        
        echo "PCMS:"
        PCMS_ROOT="$BUILD_DIR/${DEVICE_ARCH}/pcms-meshField/install"
        echo "  PCMS_ROOT: $PCMS_ROOT"
        if [ ! -d "$PCMS_ROOT" ]; then
          echo "ERROR: PCMS not found at $PCMS_ROOT"
          exit 1
        fi
        
        echo "Catch2:"
        CATCH2_ROOT="$DEPENDENCY_DIR/Catch2/install"
        echo "  CATCH2_ROOT: $CATCH2_ROOT"
        if [ ! -d "$CATCH2_ROOT" ]; then
          echo "ERROR: Catch2 not found at $CATCH2_ROOT"
          exit 1
        fi
        
        echo "Environment check complete!"
      
    - name: Build project using config.sh
      run: |
        # Use your existing config.sh script to build the project
        # It has all the correct paths to dependencies
        source ./config.sh
        
    - name: Run unit tests with CTest
      run: |
        cd build
        # Source environment to ensure tests can find dependencies
        source ../config.sh
        ctest --output-on-failure -V
    
    # Basic validation tests
    - name: Run validation tests
      run: |
        cd build
        source ../config.sh
        
        # Run the integration test with standard parameters
        ./point2MeshMap ../create_mesh/source_mesh/source_mesh.osh ../create_mesh/target_mesh/target_mesh.osh -mat_type aijkokkos -use_gpu_aware_mpi 0
        
        # Additional validation tests could be added here
        # Example: Test with different matrix types
        # ./point2MeshMap ../create_mesh/source_mesh/source_mesh.osh ../create_mesh/target_mesh/target_mesh.osh -mat_type aij -use_gpu_aware_mpi 0
        
        # Example: Test with different mesh sizes
        # If we have different test meshes:
        # ./point2MeshMap ../create_mesh/large_source_mesh/source_mesh.osh ../create_mesh/large_target_mesh/target_mesh.osh -mat_type aijkokkos -use_gpu_aware_mpi 0
        
    - name: Collect artifacts
      if: always()
      run: |
        mkdir -p artifacts
        # Copy executable
        cp build/point2MeshMap artifacts/ || true
        # Copy test results
        cp build/Testing/Temporary/LastTest.log artifacts/ || true
        # Copy any output files
        cp build/*.vtk artifacts/ || true
        
    - name: Upload artifacts
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: particle2mesh-artifacts
        path: artifacts/

  # Optional deployment job - only runs when explicitly triggered
  deploy:
    needs: build-and-test
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.release_tag != ''
    runs-on: self-hosted
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    
    - name: Download artifacts
      uses: actions/download-artifact@v3
      with:
        name: particle2mesh-artifacts
        path: release-artifacts
    
    - name: Create Release
      run: |
        RELEASE_TAG="${{ github.event.inputs.release_tag }}"
        
        if [ -z "$RELEASE_TAG" ]; then
          echo "No release tag specified, skipping release creation"
          exit 0
        fi
        
        echo "Creating release $RELEASE_TAG"
        
        # Create a release notes file
        echo "# Particle2Mesh Mapping Release $RELEASE_TAG" > release_notes.md
        echo "" >> release_notes.md
        echo "## Changes in this release:" >> release_notes.md
        
        # Get commit messages since the last tag
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        if [ -n "$LAST_TAG" ]; then
          echo "Generating changelog since $LAST_TAG"
          git log --pretty=format:"- %s" $LAST_TAG..HEAD >> release_notes.md
        else
          echo "No previous tags found, including all commit messages"
          git log --pretty=format:"- %s" >> release_notes.md
        fi
        
        # Create a tarball of the release artifacts
        cd release-artifacts
        tar -czf ../particle2mesh-${RELEASE_TAG}.tar.gz ./*
        cd ..
        
        echo "Release archive created: particle2mesh-${RELEASE_TAG}.tar.gz"
        echo "Release notes created in release_notes.md"
        
        # Here you would typically use the GitHub API to create the release
        # For a self-hosted runner, you might need to handle this differently
        # For example, upload to an internal artifact repository
        
        echo "Release $RELEASE_TAG created successfully"
        
        # Optional: Clean up
        rm -rf release-artifacts


